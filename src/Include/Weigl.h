/* 
 ElieWWW Custom font Weigl

 Weigl.h
  _____ _ _    __        ____        ____        __
 | ____| (_) __\ \      / /\ \      / /\ \      / /
 |  _| | | |/ _ \ \ /\ / /  \ \ /\ / /  \ \ /\ / / 
 | |___| | |  __/\ V  V /    \ V  V /    \ V  V /  
 |_____|_|_|\___| \_/\_/      \_/\_/      \_/\_/   
 */
 #ifndef SOKOL_DEBUGTEXT_INCLUDED
#define SOKOL_DEBUGTEXT_INCLUDED (1)
#include <stdint.h>
#include <stdbool.h>
#include <stdarg.h> // va_list

#if !defined(SOKOL_GFX_INCLUDED)
#error "Please include sokol_gfx.h before sokol_debugtext.h"
#endif

#ifndef SOKOL_API_DECL
#if defined(_WIN32) && defined(SOKOL_DLL) && defined(SOKOL_IMPL)
#define SOKOL_API_DECL __declspec(dllexport)
#elif defined(_WIN32) && defined(SOKOL_DLL)
#define SOKOL_API_DECL __declspec(dllimport)
#else
#define SOKOL_API_DECL extern
#endif
#endif

#if defined(__GNUC__)
#define SOKOL_DEBUGTEXT_PRINTF_ATTR __attribute__((format(printf, 1, 2)))
#else
#define SOKOL_DEBUGTEXT_PRINTF_ATTR
#endif

#ifdef __cplusplus
extern "C" {
#endif

/* a rendering context handle */
typedef struct sdtx_context { uint32_t id; } sdtx_context;

/* the default context handle */
static const sdtx_context SDTX_DEFAULT_CONTEXT = { 0x00010001 };

/*
    sdtx_font_desc_t

    Describes the pixel data of a font. A font consists of up to
    256 8x8 character tiles, where each character tile is described
    by 8 consecutive bytes, each byte describing 8 pixels.

    For instance the character 'A' could look like this (this is also
    how most home computers used to describe their fonts in ROM):

        bits
        7 6 5 4 3 2 1 0
        . . . X X . . .     byte 0: 0x18
        . . X X X X . .     byte 1: 0x3C
        . X X . . X X .     byte 2: 0x66
        . X X . . X X .     byte 3: 0x66
        . X X X X X X .     byte 4: 0x7E
        . X X . . X X .     byte 5: 0x66
        . X X . . X X .     byte 6: 0x66
        . . . . . . . .     byte 7: 0x00
 */
#define SDTX_MAX_FONTS (8)

typedef struct sdtx_font_desc_t {
    const uint8_t* ptr;     // pointer to font pixel data
    int16_t size;           // byte size of font pixel data
    uint8_t first_char;     // first character index in font pixel data
    uint8_t last_char;      // last character index in font pixel data, inclusive (default: 255)
} sdtx_font_desc_t;

/*
    sdtx_context_desc_t

    Describes the initialization parameters of a rendering context. Creating
    additional rendering contexts is useful if you want to render in
    different sokol-gfx rendering passes, or when rendering several layers
    of text.
*/
typedef struct sdtx_context_desc_t {
    int char_buf_size;                      // max number of characters rendered in one frame, default: 4096
    float canvas_width;                     // the initial virtual canvas width, default: 640
    float canvas_height;                    // the initial virtual canvas height, default: 400
    int tab_width;                          // tab width in number of characters, default: 4
    sg_pixel_format color_format;           // color pixel format of target render pass
    sg_pixel_format depth_format;           // depth pixel format of target render pass
    int sample_count;                       // MSAA sample count of target render pass
} sdtx_context_desc_t;

/*
    sdtx_desc_t

    Describes the sokol-debugtext API initialization parameters. Passed
    to the sdtx_setup() function.

    NOTE: to populate the fonts item array with builtin fonts, use any
    of the following functions:

        sdtx_font_kc853()
        sdtx_font_kc854()
        sdtx_font_z1013()
        sdtx_font_cpc()
        sdtx_font_c64()
        sdtx_font_oric()
*/
typedef struct sdtx_desc_t {
    int context_pool_size;                  // max number of rendering contexts that can be created, default: 8
    int printf_buf_size;                    // size of internal buffer for snprintf(), default: 4096
    sdtx_font_desc_t fonts[SDTX_MAX_FONTS]; // up to 8 fonts descriptions
    sdtx_context_desc_t context;            // the default context creation parameters
} sdtx_desc_t;

/* initialization/shutdown */
SOKOL_API_DECL void sdtx_setup(const sdtx_desc_t* desc);
SOKOL_API_DECL void sdtx_shutdown(void);

/* builtin font data (use to populate sdtx_desc.font[]) */
SOKOL_API_DECL sdtx_font_desc_t _elie_font_Weigl(void);

/* context functions */
SOKOL_API_DECL sdtx_context sdtx_make_context(const sdtx_context_desc_t* desc);
SOKOL_API_DECL void sdtx_destroy_context(sdtx_context ctx);
SOKOL_API_DECL void sdtx_set_context(sdtx_context ctx);
SOKOL_API_DECL sdtx_context sdtx_get_context(void);

/* draw and rewind the current context */
SOKOL_API_DECL void sdtx_draw(void);

/* switch to a different font */
SOKOL_API_DECL void sdtx_font(int font_index);

/* set a new virtual canvas size in screen pixels */
SOKOL_API_DECL void sdtx_canvas(float w, float h);

/* set a new origin in character grid coordinates */
SOKOL_API_DECL void sdtx_origin(float x, float y);

/* cursor movement functions (relative to origin in character grid coordinates) */
SOKOL_API_DECL void sdtx_home(void);
SOKOL_API_DECL void sdtx_pos(float x, float y);
SOKOL_API_DECL void sdtx_pos_x(float x);
SOKOL_API_DECL void sdtx_pos_y(float y);
SOKOL_API_DECL void sdtx_move(float dx, float dy);
SOKOL_API_DECL void sdtx_move_x(float dx);
SOKOL_API_DECL void sdtx_move_y(float dy);
SOKOL_API_DECL void sdtx_crlf(void);

/* set the current text color */
SOKOL_API_DECL void sdtx_color3b(uint8_t r, uint8_t g, uint8_t b);              // RGB 0..255, A=255
SOKOL_API_DECL void sdtx_color3f(float r, float g, float b);                    // RGB 0.0f..1.0f, A=1.0f
SOKOL_API_DECL void sdtx_color4b(uint8_t r, uint8_t g, uint8_t b, uint8_t a);   // RGBA 0..255
SOKOL_API_DECL void sdtx_color4f(float r, float g, float b, float a);           // RGBA 0.0f..1.0f
SOKOL_API_DECL void sdtx_color1i(uint32_t rgba); 


/* text rendering */
SOKOL_API_DECL void sdtx_putc(char c);
SOKOL_API_DECL void sdtx_puts(const char* str);             // does NOT append newline!
SOKOL_API_DECL void sdtx_putr(const char* str, int len);    // 'put range', also stops at zero-char
SOKOL_API_DECL int sdtx_printf(const char* fmt, ...) SOKOL_DEBUGTEXT_PRINTF_ATTR;
SOKOL_API_DECL int sdtx_vprintf(const char* fmt, va_list args);


#ifdef __cplusplus
} /* extern "C" */
/* C++ const-ref wrappers */
inline void sdtx_setup(const sdtx_desc_t& desc) { return sdtx_setup(&desc); }
inline sdtx_context sdtx_make_context(const sdtx_context_desc_t& desc) { return sdtx_make_context(&desc); }
#endif
#endif /* SOKOL_DEBUGTEXT_INCLUDED */

/*-- IMPLEMENTATION ----------------------------------------------------------*/
#ifdef SOKOL_DEBUGTEXT_IMPL
#define SOKOL_DEBUGTEXT_IMPL_INCLUDED (1)

#include <string.h> // memset
#include <math.h>   // fmodf
#include <stdarg.h> // for vsnprintf

#ifndef SOKOL_API_IMPL
    #define SOKOL_API_IMPL
#endif
#ifndef SOKOL_DEBUG
    #ifndef NDEBUG
        #define SOKOL_DEBUG (1)
    #endif
#endif
#ifndef SOKOL_ASSERT
    #include <assert.h>
    #define SOKOL_ASSERT(c) assert(c)
#endif
#ifndef SOKOL_MALLOC
    #include <stdlib.h>
    #define SOKOL_MALLOC(s) malloc(s)
    #define SOKOL_FREE(p) free(p)
#endif
#ifndef SOKOL_LOG
    #ifdef SOKOL_DEBUG
        #include <stdio.h>
        #define SOKOL_LOG(s) { SOKOL_ASSERT(s); puts(s); }
    #else
        #define SOKOL_LOG(s)
    #endif
#endif
#ifndef SOKOL_UNREACHABLE
    #define SOKOL_UNREACHABLE SOKOL_ASSERT(false)
#endif
#ifndef _SOKOL_UNUSED
    #define _SOKOL_UNUSED(x) (void)(x)
#endif

#ifndef SOKOL_VSNPRINTF
#include <stdio.h>
#define SOKOL_VSNPRINTF vsnprintf
#endif

#define _sdtx_def(val, def) (((val) == 0) ? (def) : (val))
#define _SDTX_INIT_COOKIE (0xACBAABCA)

#define _SDTX_DEFAULT_CONTEXT_POOL_SIZE (8)
#define _SDTX_DEFAULT_CHAR_BUF_SIZE (1<<12)
#define _SDTX_DEFAULT_PRINTF_BUF_SIZE (1<<12)
#define _SDTX_DEFAULT_CANVAS_WIDTH (640)
#define _SDTX_DEFAULT_CANVAS_HEIGHT (480)
#define _SDTX_DEFAULT_TAB_WIDTH (4)
#define _SDTX_DEFAULT_COLOR (0xFF00FFFF)
#define _SDTX_INVALID_SLOT_INDEX (0)
#define _SDTX_SLOT_SHIFT (16)
#define _SDTX_MAX_POOL_SIZE (1<<_SDTX_SLOT_SHIFT)
#define _SDTX_SLOT_MASK (_SDTX_MAX_POOL_SIZE-1)



const uint8_t _elie_font_Weigl[2048] = {
  0x00, 0x00, 0x80, 0x40, 0x60, 0x30, 0x38, 0x1C, 0x1C, 0x0E, 0x07, 0x07,
  0x03, 0x83, 0x81, 0x80, 0xC0, 0x60, 0x10, 0x00, 0x00, 0x0C, 0x0E, 0x0F,
  0x07, 0x03, 0x01, 0x80, 0x8C, 0xF7, 0xBD, 0xEF, 0x6B, 0x58, 0x00, 0x00,
  0x00, 0x18, 0x00, 0x0E, 0x00, 0x0E, 0x00, 0x07, 0x00, 0x03, 0x80, 0x03,
  0x80, 0x07, 0xF8, 0x07, 0xFF, 0x07, 0x63, 0x83, 0x30, 0x03, 0x98, 0x01,
  0xD8, 0x00, 0x4C, 0x00, 0x3E, 0x00, 0x1E, 0x00, 0x07, 0x00, 0x03, 0xC0,
  0x03, 0xE0, 0x01, 0x98, 0x00, 0xCC, 0x00, 0x67, 0x00, 0x61, 0x80, 0x30,
  0xC1, 0x18, 0xC0, 0x48, 0x60, 0x3C, 0x60, 0x0F, 0xE0, 0x03, 0xC0, 0x01,
  0x80, 0x00, 0xC0, 0x00, 0xC0, 0x00, 0x60, 0x00, 0x30, 0x00, 0x18, 0x00,
  0x0C, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x00, 0x70, 0x10, 0x38,
  0x0E, 0x1C, 0x05, 0x0E, 0x02, 0x47, 0x00, 0xA3, 0x80, 0x49, 0xC0, 0x1C,
  0xE0, 0x06, 0x30, 0x00, 0x1C, 0x00, 0x0E, 0x1C, 0x07, 0x0E, 0x03, 0x86,
  0x80, 0xE1, 0x40, 0x70, 0x90, 0x38, 0x38, 0x0C, 0x0C, 0x07, 0x00, 0x01,
  0x80, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x0F, 0xE0, 0x06, 0x10,
  0x03, 0x0C, 0x01, 0x86, 0x00, 0x61, 0x00, 0x30, 0x80, 0x0C, 0xC0, 0x03,
  0x60, 0x00, 0xF0, 0x00, 0x78, 0x00, 0x3E, 0x00, 0x1D, 0x81, 0xC6, 0x31,
  0xE3, 0x04, 0xE0, 0x81, 0xE0, 0x60, 0x70, 0x10, 0x1C, 0x0C, 0x0F, 0x83,
  0x06, 0x60, 0xE3, 0x0C, 0x3F, 0x80, 0x07, 0x80, 0x00, 0x00, 0x00, 0x00,
  0x63, 0x9D, 0xFF, 0xF8, 0x01, 0x80, 0x0E, 0x00, 0x38, 0x00, 0xE0, 0x03,
  0x80, 0x0E, 0x00, 0x3F, 0xC3, 0xFF, 0xFF, 0xE3, 0xFC, 0x0E, 0x70, 0x01,
  0xC0, 0x07, 0x00, 0x1C, 0x00, 0x70, 0x01, 0xC0, 0x03, 0x00, 0x0C, 0x00,
  0x19, 0xCC, 0xE6, 0x73, 0x18, 0x80, 0x1F, 0xEF, 0xFF, 0x7F, 0x80, 0x21,
  0xDE, 0xFF, 0xF9, 0x80, 0x00, 0x00, 0x80, 0x0E, 0x01, 0xE0, 0x7F, 0x0F,
  0xF0, 0xFF, 0x1D, 0xB3, 0xBB, 0x3B, 0x37, 0x23, 0x70, 0x36, 0x03, 0x60,
  0x36, 0x07, 0xE0, 0x6E, 0x06, 0x60, 0x66, 0x0E, 0x70, 0xC3, 0xF8, 0x3F,
  0x81, 0xE0, 0x39, 0xCE, 0x73, 0x9C, 0xE6, 0x33, 0x9C, 0xE6, 0x31, 0x9C,
  0xE7, 0x39, 0xCE, 0x20, 0x03, 0xFE, 0x03, 0xFF, 0x83, 0xFC, 0xE0, 0xF0,
  0x38, 0x00, 0x1E, 0x00, 0x0F, 0x00, 0x07, 0x80, 0x03, 0xC0, 0x01, 0xE0,
  0x00, 0xF0, 0x00, 0xF8, 0x00, 0x7C, 0x00, 0x1E, 0x00, 0x0F, 0x00, 0x07,
  0x80, 0x31, 0xC3, 0xFF, 0xFF, 0xFF, 0x9F, 0xE0, 0x01, 0x80, 0x00, 0x00,
  0xF0, 0x1F, 0xF0, 0x7F, 0xE0, 0x63, 0xC0, 0x1E, 0x00, 0x38, 0x00, 0xE0,
  0x01, 0xC0, 0x03, 0xE0, 0x03, 0xE0, 0x03, 0xF0, 0x03, 0xE0, 0x01, 0xE0,
  0x01, 0xC0, 0x03, 0x80, 0x07, 0x70, 0x1F, 0xFF, 0xF8, 0xFF, 0xE0, 0x3F,
  0x00, 0x10, 0x23, 0x07, 0x70, 0x77, 0x0E, 0x70, 0xEE, 0x0E, 0xE0, 0xCE,
  0x1C, 0xE1, 0xCF, 0xF8, 0x7F, 0x87, 0xF8, 0x03, 0x80, 0x30, 0x07, 0x00,
  0x70, 0x07, 0x00, 0x70, 0x07, 0x00, 0x70, 0x03, 0x00, 0x00, 0x07, 0xF0,
  0x01, 0xFF, 0x80, 0x1F, 0x00, 0x01, 0xE0, 0x00, 0x0E, 0x00, 0x00, 0xE0,
  0x00, 0x06, 0x00, 0x00, 0x70, 0x00, 0x03, 0x00, 0x00, 0x3F, 0xC0, 0x01,
  0xFF, 0x80, 0x07, 0xFE, 0x00, 0x00, 0x38, 0x00, 0x00, 0xC0, 0x00, 0x06,
  0x10, 0x00, 0x70, 0xE0, 0x03, 0x07, 0x00, 0x38, 0x38, 0x0F, 0x80, 0xFF,
  0xF8, 0x03, 0xFF, 0x00, 0x00, 0x00, 0x01, 0x00, 0x07, 0x00, 0x0E, 0x00,
  0x1C, 0x00, 0x38, 0x00, 0x70, 0x00, 0xE0, 0x01, 0xC0, 0x03, 0x80, 0x07,
  0x00, 0x0E, 0x10, 0x0E, 0xFC, 0x1F, 0xFE, 0x3F, 0x8E, 0x3F, 0x06, 0x76,
  0x06, 0x60, 0x0E, 0xE0, 0x0E, 0xE0, 0x1C, 0xE0, 0x1C, 0xE0, 0x38, 0xE0,
  0x78, 0x71, 0xF0, 0x7F, 0xE0, 0x3F, 0x80, 0x04, 0x00, 0x3F, 0xE0, 0x7F,
  0xFF, 0xBF, 0xFF, 0xE0, 0x01, 0xE0, 0x00, 0xF0, 0x00, 0x70, 0x00, 0x78,
  0x00, 0x78, 0x00, 0x7C, 0x00, 0x3C, 0x00, 0x3E, 0x00, 0x1E, 0x00, 0x0E,
  0x00, 0x0F, 0x00, 0x07, 0x00, 0x07, 0x80, 0x03, 0x80, 0x03, 0xC0, 0x01,
  0xC0, 0x00, 0xE0, 0x00, 0x70, 0x00, 0x30, 0x00, 0x07, 0xF0, 0xFF, 0xCF,
  0xDE, 0x70, 0x77, 0x83, 0xB8, 0x1D, 0xC1, 0xCE, 0x3C, 0x7F, 0xE1, 0xFC,
  0x0F, 0xC0, 0x78, 0x07, 0xE0, 0x3B, 0x81, 0x8C, 0x1C, 0x70, 0xE1, 0x87,
  0x0C, 0x38, 0x61, 0xC3, 0x07, 0x18, 0x3F, 0xC0, 0xFC, 0x03, 0xC0, 0x03,
  0x03, 0xC7, 0xE7, 0xF7, 0xFF, 0x8B, 0x85, 0xC6, 0xEF, 0x7F, 0x09, 0x80,
  0xC0, 0x60, 0x30, 0x38, 0x1C, 0x0E, 0x06, 0x03, 0x01, 0x80, 0xC0, 0x60,
  0x30, 0x18, 0x0C, 0x00, 0x08, 0xC4, 0x00, 0x00, 0x00, 0x73, 0xBD, 0xC4,
  0x00, 0x33, 0x30, 0x00, 0x11, 0x32, 0x66, 0x6E, 0xEC, 0x80, 0x00, 0x7F,
  0xFF, 0xF3, 0xF0, 0x00, 0x3F, 0xBF, 0xF7, 0xF8, 0x00, 0x00, 0x20, 0x0F,
  0xF3, 0xFF, 0xFF, 0x87, 0x30, 0x1C, 0x00, 0xE0, 0x07, 0x00, 0x38, 0x03,
  0xC0, 0x1E, 0x00, 0xF0, 0x0F, 0x80, 0x7C, 0x03, 0xE0, 0x0F, 0x00, 0x38,
  0x00, 0xFF, 0x01, 0xFC, 0x03, 0xC0, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x07,
  0x00, 0x38, 0x00, 0xC0, 0x00, 0x00, 0x00, 0x20, 0x00, 0x01, 0xFC, 0x00,
  0x07, 0xFE, 0x00, 0x0F, 0x06, 0x00, 0x3C, 0x06, 0x00, 0x70, 0x07, 0x00,
  0xE0, 0x07, 0x01, 0xC0, 0x07, 0x03, 0xBE, 0x07, 0x07, 0x7F, 0x07, 0x07,
  0xE7, 0x06, 0x0D, 0x83, 0x0E, 0x1B, 0x83, 0x0E, 0x3B, 0x07, 0x0C, 0x36,
  0x0F, 0x1C, 0x76, 0x1F, 0x1C, 0x66, 0x7B, 0x38, 0xE7, 0xF3, 0xF0, 0xE3,
  0xC3, 0xE0, 0xE0, 0x01, 0xC0, 0xC0, 0x00, 0x00, 0xE0, 0x00, 0x00, 0xE0,
  0x00, 0x00, 0x60, 0x00, 0x04, 0x70, 0x00, 0x1E, 0x3C, 0x00, 0xFC, 0x1F,
  0xFF, 0xF0, 0x07, 0xFF, 0x80, 0x00, 0x70, 0x00, 0x00, 0x0C, 0x00, 0x3E,
  0x00, 0x3E, 0x00, 0x7E, 0x00, 0xFE, 0x00, 0xFF, 0x01, 0xE7, 0x03, 0xC7,
  0x03, 0x87, 0x07, 0x87, 0x07, 0x07, 0x0F, 0x07, 0x0E, 0x06, 0x1E, 0x06,
  0x1C, 0x1E, 0x1F, 0xFE, 0x38, 0x06, 0x30, 0x06, 0x70, 0x06, 0x60, 0x06,
  0x60, 0x06, 0xC0, 0x06, 0xC0, 0x06, 0x00, 0x0E, 0x00, 0x06, 0x00, 0x3F,
  0x00, 0x7F, 0xC0, 0x3F, 0xF0, 0x3E, 0x0C, 0x1E, 0x0F, 0x07, 0x07, 0x00,
  0x0D, 0x80, 0x03, 0x78, 0x00, 0xCF, 0x00, 0x71, 0xE0, 0x18, 0x1C, 0x06,
  0x03, 0x01, 0x80, 0xC0, 0x60, 0x30, 0x30, 0x1C, 0x0C, 0x07, 0x03, 0x03,
  0x80, 0x81, 0xE0, 0x61, 0xF0, 0x18, 0xF0, 0x0F, 0xF0, 0x3F, 0xF0, 0x07,
  0xF0, 0x00, 0x00, 0x1E, 0x00, 0x0F, 0xE0, 0x03, 0xFE, 0x00, 0xF9, 0xC0,
  0x3E, 0x10, 0x0F, 0x00, 0x03, 0xE0, 0x00, 0x78, 0x00, 0x1E, 0x00, 0x03,
  0x80, 0x00, 0xF0, 0x00, 0x1C, 0x00, 0x07, 0x00, 0x00, 0xE0, 0x00, 0x1C,
  0x00, 0x1F, 0x00, 0x0F, 0xE0, 0x03, 0xFC, 0x01, 0xFB, 0x80, 0xFC, 0x78,
  0x7F, 0x07, 0xFF, 0x80, 0x7F, 0xC0, 0x03, 0x80, 0x00, 0x00, 0x3F, 0xC0,
  0x0F, 0xFF, 0xC0, 0xFF, 0xFF, 0x0F, 0xE0, 0x1E, 0x7C, 0x00, 0x38, 0x80,
  0x80, 0x70, 0x07, 0x01, 0xC0, 0x1C, 0x07, 0x00, 0x70, 0x1C, 0x01, 0xC0,
  0xE0, 0x0E, 0x03, 0x80, 0x38, 0x1E, 0x00, 0xE0, 0xF0, 0x03, 0x87, 0x80,
  0x0C, 0x3C, 0x00, 0x31, 0xF0, 0x01, 0xDF, 0x00, 0x07, 0xF8, 0x07, 0xFF,
  0x80, 0x3F, 0xF8, 0x00, 0x3F, 0x80, 0x00, 0x06, 0x00, 0x00, 0x18, 0x00,
  0x00, 0x03, 0xFE, 0x0F, 0xF8, 0x38, 0x00, 0x70, 0x00, 0xC0, 0x03, 0x80,
  0x07, 0x00, 0x0E, 0x00, 0x1F, 0x18, 0x3F, 0xF8, 0xFF, 0xE1, 0xFF, 0x03,
  0xC0, 0x07, 0x80, 0x0E, 0x00, 0x3C, 0x00, 0x70, 0x01, 0xE0, 0x23, 0xFF,
  0xF7, 0xFF, 0xEF, 0xFF, 0x00, 0x00, 0x0F, 0x07, 0xFF, 0xDF, 0xFE, 0x1F,
  0xC0, 0x00, 0xE0, 0x00, 0x70, 0x00, 0x38, 0x00, 0x38, 0x00, 0x1C, 0x00,
  0x0E, 0x00, 0x0F, 0x00, 0x07, 0x80, 0x0F, 0xFE, 0x07, 0xFF, 0x01, 0xFF,
  0x00, 0xE0, 0x00, 0x70, 0x00, 0x38, 0x00, 0x1C, 0x00, 0x0E, 0x00, 0x0F,
  0x00, 0x03, 0x80, 0x00, 0x00, 0x30, 0x03, 0xE0, 0x1F, 0x80, 0xFE, 0x07,
  0xD8, 0x1E, 0xC0, 0xF2, 0x07, 0xC0, 0x1E, 0x00, 0xF0, 0x03, 0xC0, 0x0E,
  0x00, 0x70, 0x01, 0xC1, 0xC6, 0x0F, 0x38, 0x7E, 0xE1, 0xEB, 0x8F, 0x2E,
  0x39, 0xBF, 0xC6, 0x7E, 0x30, 0x78, 0xC0, 0xC7, 0x06, 0x18, 0x30, 0xC0,
  0xC3, 0x06, 0x18, 0x18, 0x60, 0x63, 0x03, 0x98, 0x0E, 0xE0, 0x3F, 0x00,
  0xF8, 0x03, 0xC0, 0x00, 0x02, 0x00, 0x0C, 0x00, 0x70, 0x01, 0xC1, 0x07,
  0x04, 0x38, 0x30, 0xE0, 0xC3, 0x06, 0x1C, 0x18, 0x70, 0x43, 0x83, 0x0E,
  0x08, 0x3F, 0xE1, 0xFF, 0x87, 0x04, 0x1C, 0x30, 0xE0, 0xC3, 0x86, 0x0E,
  0x18, 0x30, 0x60, 0xC1, 0x82, 0x04, 0x00, 0x04, 0x0C, 0x18, 0x70, 0xE1,
  0x83, 0x0E, 0x1C, 0x30, 0xE1, 0xC3, 0x06, 0x1C, 0x30, 0x61, 0xC3, 0x87,
  0x0E, 0x08, 0x00, 0x00, 0x20, 0x07, 0x1F, 0xE1, 0xFE, 0x00, 0xC0, 0x0C,
  0x01, 0xC0, 0x1C, 0x01, 0xC0, 0x1C, 0x01, 0x80, 0x18, 0x01, 0x80, 0x18,
  0x01, 0x80, 0x18, 0x01, 0x80, 0x18, 0xC1, 0xCE, 0x1C, 0x38, 0xC1, 0xEC,
  0x0F, 0xC0, 0x3C, 0x00, 0x00, 0x60, 0x01, 0x80, 0xCE, 0x07, 0x38, 0x78,
  0xE3, 0xC3, 0x9E, 0x0C, 0xF0, 0x37, 0x80, 0xF8, 0x03, 0xC0, 0x0E, 0x00,
  0x30, 0x01, 0xE0, 0x07, 0x80, 0x1F, 0x80, 0x7F, 0x01, 0xBE, 0x06, 0x3C,
  0x38, 0x78, 0xE0, 0xF3, 0x00, 0xC8, 0x00, 0x00, 0x18, 0x03, 0x80, 0x70,
  0x0E, 0x01, 0xC0, 0x38, 0x06, 0x00, 0xC0, 0x38, 0x07, 0x00, 0xE0, 0x18,
  0x03, 0x00, 0x60, 0x1C, 0x03, 0x00, 0x60, 0x0C, 0x03, 0x83, 0xFF, 0xFF,
  0xFC, 0xF8, 0x00, 0x04, 0x0C, 0x06, 0x1C, 0x0E, 0x1C, 0x0E, 0x3C, 0x0E,
  0x3C, 0x0F, 0x3C, 0x1F, 0x3C, 0x1B, 0x6C, 0x1B, 0x7C, 0x3B, 0x7C, 0x33,
  0xDC, 0x31, 0xCC, 0x31, 0x8C, 0x70, 0x0C, 0x60, 0x0C, 0x60, 0x0C, 0xE0,
  0x0C, 0xE0, 0x0C, 0xE0, 0x0E, 0xE0, 0x06, 0xE0, 0x06, 0xC0, 0x03, 0x80,
  0x02, 0x08, 0x00, 0x30, 0x10, 0xC0, 0x43, 0x03, 0x0C, 0x0C, 0x70, 0x31,
  0xC0, 0xC7, 0x03, 0x1C, 0x0C, 0x70, 0x63, 0xC1, 0x8F, 0x06, 0x3C, 0x18,
  0xF0, 0x62, 0x61, 0x99, 0x84, 0x66, 0x31, 0x98, 0xC4, 0x33, 0x10, 0xF8,
  0xC1, 0xE3, 0x03, 0x08, 0x00, 0x00, 0x03, 0xE0, 0x0F, 0xF0, 0x3C, 0xE0,
  0xF1, 0xE1, 0xC2, 0x47, 0x08, 0xDC, 0x01, 0xB0, 0x03, 0xE0, 0x0F, 0x80,
  0x1F, 0x00, 0x34, 0x00, 0xE8, 0x03, 0xD0, 0x07, 0x20, 0x1E, 0x40, 0x78,
  0xC1, 0xE1, 0x87, 0x83, 0xFE, 0x03, 0xF0, 0x03, 0x80, 0x00, 0x00, 0x7F,
  0x00, 0x7F, 0xF8, 0x7F, 0xFF, 0x9F, 0xE1, 0xF7, 0xE6, 0x0F, 0xF1, 0xE1,
  0xFC, 0x38, 0x3F, 0x07, 0x1F, 0xE0, 0xEF, 0xCC, 0x3F, 0xF0, 0x0F, 0xFC,
  0x03, 0xFE, 0x00, 0xFE, 0x00, 0x0F, 0x00, 0x01, 0xC0, 0x00, 0x70, 0x00,
  0x0E, 0x00, 0x03, 0xC0, 0x00, 0x78, 0x00, 0x0F, 0x00, 0x01, 0xE0, 0x00,
  0x38, 0x00, 0x07, 0x00, 0x00, 0x60, 0x00, 0x00, 0x01, 0x80, 0x08, 0xC0,
  0x3E, 0xE0, 0x3F, 0x70, 0x3F, 0xB8, 0x38, 0xDC, 0x3C, 0x0C, 0x3C, 0x06,
  0x3C, 0x07, 0x1E, 0x03, 0x0E, 0x03, 0x8F, 0x01, 0xC7, 0x01, 0xC3, 0x86,
  0xE1, 0xC3, 0xE1, 0xC1, 0xF0, 0xE0, 0xF0, 0x70, 0x78, 0x38, 0x3E, 0x1C,
  0x3F, 0x8E, 0x3D, 0xF7, 0xFC, 0xF9, 0xFC, 0x3C, 0xF8, 0x0E, 0x00, 0x7F,
  0x80, 0x3F, 0xFE, 0x0F, 0xC0, 0x73, 0xE0, 0x03, 0x70, 0x20, 0x3E, 0x06,
  0x03, 0xC0, 0x40, 0x78, 0x0C, 0x1E, 0x80, 0xC7, 0xCC, 0x19, 0xF0, 0x71,
  0xBC, 0x03, 0x33, 0x80, 0x03, 0x38, 0x00, 0x73, 0x80, 0x06, 0x1C, 0x00,
  0xE1, 0xC0, 0x0C, 0x1C, 0x00, 0xC0, 0xE0, 0x18, 0x0E, 0x01, 0x80, 0xF0,
  0x10, 0x07, 0x01, 0x00, 0x70, 0x00, 0x03, 0x00, 0x00, 0x0F, 0x00, 0x3F,
  0xC0, 0x7F, 0xE0, 0x7C, 0x30, 0x78, 0x30, 0x38, 0x10, 0x1C, 0x00, 0x1C,
  0x00, 0x06, 0x00, 0x03, 0x80, 0x01, 0xC0, 0x00, 0x70, 0x00, 0x1C, 0x00,
  0x0E, 0x00, 0x03, 0x80, 0x00, 0xE0, 0x00, 0x38, 0x00, 0x1E, 0x3C, 0x07,
  0x0F, 0x81, 0xC1, 0xFF, 0xE0, 0x1F, 0xF0, 0x01, 0xF0, 0x00, 0x06, 0x0F,
  0xFE, 0x00, 0x0F, 0xFF, 0xFF, 0xDF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
  0x00, 0x0F, 0x01, 0xF0, 0x00, 0x03, 0x80, 0xF0, 0x00, 0x00, 0x80, 0x70,
  0x00, 0x00, 0x00, 0x38, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x0E,
  0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x03,
  0x80, 0x00, 0x00, 0x03, 0xC0, 0x00, 0x00, 0x01, 0xC0, 0x00, 0x00, 0x00,
  0xE0, 0x00, 0x00, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x70, 0x00, 0x00, 0x00,
  0x38, 0x00, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x00, 0x0E, 0x00, 0x00, 0x00,
  0x07, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00,
  0x00, 0xC0, 0x00, 0x00, 0x00, 0x1C, 0x30, 0x70, 0xE3, 0xC3, 0x8F, 0x0E,
  0x30, 0x1D, 0xC0, 0x77, 0x01, 0xDC, 0x06, 0x60, 0x1B, 0x80, 0xEE, 0x03,
  0xB8, 0x1E, 0xE0, 0x73, 0x81, 0xCE, 0x0F, 0x38, 0x78, 0xE1, 0xE3, 0x8F,
  0x0E, 0x78, 0x1F, 0xE0, 0x7F, 0x00, 0xF0, 0x00, 0x00, 0x00, 0x1C, 0x00,
  0x01, 0xF0, 0x00, 0x0F, 0xC0, 0x00, 0x7C, 0xC0, 0x03, 0xE3, 0x00, 0x1F,
  0x0C, 0x00, 0x78, 0x30, 0x03, 0xC0, 0xE0, 0x1E, 0x03, 0x80, 0x70, 0x0E,
  0x03, 0xC0, 0x38, 0x1E, 0x00, 0xE0, 0x70, 0x03, 0x83, 0xC0, 0x0E, 0x1E,
  0x00, 0x38, 0x70, 0x00, 0xE3, 0xC0, 0x01, 0x9E, 0x00, 0x06, 0x70, 0x00,
  0x1F, 0xC0, 0x00, 0x7E, 0x00, 0x01, 0xF8, 0x00, 0x03, 0xC0, 0x00, 0x0E,
  0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x1C, 0x00, 0x00, 0x30, 0x00,
  0x00, 0xE0, 0x00, 0x01, 0x80, 0x00, 0x07, 0x00, 0x00, 0x0E, 0x30, 0x00,
  0x18, 0x70, 0x00, 0x71, 0xE0, 0x00, 0xE3, 0xC0, 0x03, 0x87, 0x00, 0x07,
  0x0E, 0x00, 0x0C, 0x1C, 0x00, 0x38, 0x38, 0x00, 0x70, 0x70, 0x01, 0xC0,
  0xE0, 0x03, 0x81, 0xC7, 0x06, 0x03, 0x9E, 0x1C, 0x07, 0x7C, 0x30, 0x0F,
  0xD8, 0xE0, 0x1F, 0xBB, 0x80, 0x1E, 0x7F, 0x00, 0x38, 0x7C, 0x00, 0x00,
  0x00, 0x0E, 0x04, 0x00, 0x78, 0x0C, 0x01, 0xE0, 0x18, 0x0F, 0x80, 0x30,
  0x3C, 0x00, 0x71, 0xE0, 0x00, 0xE7, 0x00, 0x00, 0xFC, 0x00, 0x01, 0xF0,
  0x00, 0x03, 0xC0, 0x00, 0x0F, 0x00, 0x00, 0x1E, 0x00, 0x00, 0x7C, 0x00,
  0x01, 0xD8, 0x00, 0x07, 0xB8, 0x00, 0x1E, 0x70, 0x00, 0x38, 0x60, 0x00,
  0xE0, 0xE0, 0x01, 0x81, 0xC0, 0x07, 0x01, 0xC0, 0x0E, 0x03, 0x80, 0x18,
  0x03, 0x00, 0x00, 0x00, 0x06, 0x08, 0x1C, 0x38, 0x30, 0x70, 0xE0, 0xE1,
  0x80, 0xC7, 0x01, 0x8C, 0x03, 0x98, 0x07, 0x60, 0x0E, 0xC0, 0x0F, 0x00,
  0x1E, 0x00, 0x38, 0x00, 0x70, 0x00, 0xC0, 0x03, 0x80, 0x0E, 0x00, 0x1C,
  0x00, 0x70, 0x00, 0xE0, 0x03, 0x80, 0x07, 0x00, 0x0E, 0x00, 0x38, 0x00,
  0x70, 0x00, 0xE0, 0x03, 0x80, 0x07, 0x00, 0x0E, 0x00, 0x1C, 0x00, 0x38,
  0x00, 0x70, 0x00, 0x60, 0x00, 0x00, 0x3F, 0xE0, 0x0F, 0xFE, 0x03, 0xF8,
  0xE0, 0x3C, 0x3C, 0x00, 0x07, 0x80, 0x00, 0xF0, 0x00, 0x1E, 0x00, 0x03,
  0xC0, 0x00, 0x78, 0x00, 0x0F, 0x00, 0x01, 0xE0, 0x00, 0x3C, 0x00, 0x07,
  0x80, 0x00, 0xF0, 0x00, 0x1E, 0x00, 0x03, 0xC0, 0x00, 0x38, 0x00, 0x07,
  0x81, 0xFF, 0x70, 0xFF, 0xFF, 0xFF, 0xF0, 0xFF, 0xE0, 0x0F, 0xF0, 0x00,
  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x81, 0xFC, 0x7F, 0x8E, 0x33,
  0x86, 0x60, 0xDC, 0x1B, 0x07, 0x60, 0xEC, 0x3F, 0x87, 0xB1, 0xF6, 0x7E,
  0xFF, 0xCF, 0x98, 0x02, 0x04, 0x00, 0x70, 0x03, 0x80, 0x38, 0x01, 0xC0,
  0x0E, 0x00, 0xE0, 0x07, 0x00, 0x38, 0x01, 0x80, 0x1C, 0x70, 0xEF, 0xF6,
  0xFF, 0xBE, 0x1D, 0xE0, 0xFE, 0x07, 0xE0, 0x37, 0x03, 0xB0, 0x39, 0x83,
  0x8C, 0x38, 0x63, 0x83, 0xF8, 0x0F, 0x80, 0x03, 0x01, 0xF0, 0x7E, 0x1C,
  0x07, 0x00, 0xC0, 0x38, 0x06, 0x00, 0xC0, 0x18, 0x03, 0x00, 0x70, 0x3F,
  0x8E, 0xFF, 0x8F, 0xE0, 0x00, 0x01, 0x00, 0x03, 0x00, 0x07, 0x00, 0x06,
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x38, 0x00, 0x38,
  0x0E, 0x30, 0x1F, 0xF0, 0x39, 0xF0, 0x70, 0xE0, 0x60, 0xE0, 0x60, 0xE0,
  0x61, 0xE0, 0xC1, 0xE0, 0xC3, 0xE0, 0xC3, 0xE0, 0x67, 0xE0, 0x7E, 0xE0,
  0x7C, 0xE0, 0x38, 0xE0, 0x03, 0x80, 0xFE, 0x1C, 0x61, 0x83, 0x30, 0x63,
  0xCE, 0x7F, 0xE7, 0xF8, 0x60, 0x0E, 0x00, 0xE0, 0x0C, 0x0C, 0xE7, 0xCF,
  0xF8, 0x7E, 0x00, 0x00, 0x10, 0x01, 0xF8, 0x03, 0xF8, 0x0E, 0x60, 0x18,
  0xC0, 0x70, 0x00, 0xE0, 0x01, 0x80, 0x07, 0x00, 0x0E, 0x00, 0x1F, 0xE0,
  0xFF, 0x8F, 0xF0, 0x1D, 0xC0, 0x03, 0x00, 0x0E, 0x00, 0x1C, 0x00, 0x38,
  0x00, 0x70, 0x00, 0xC0, 0x01, 0x80, 0x03, 0x00, 0x06, 0x00, 0x0C, 0x00,
  0x38, 0x00, 0x70, 0x00, 0x60, 0x00, 0x00, 0x03, 0xC0, 0x00, 0xFC, 0x00,
  0x7F, 0x80, 0x1E, 0x30, 0x07, 0x06, 0x00, 0xC1, 0xC0, 0x38, 0x38, 0x0E,
  0x0E, 0x01, 0x81, 0xC0, 0x70, 0x70, 0x0E, 0x1C, 0x01, 0xFF, 0x00, 0x1F,
  0xC0, 0x01, 0xF8, 0x00, 0x7F, 0x00, 0x1C, 0xE0, 0x03, 0x38, 0x00, 0xC7,
  0x00, 0x31, 0xC0, 0x0C, 0x70, 0x03, 0x1E, 0x00, 0x63, 0x80, 0x18, 0xE0,
  0x03, 0x3C, 0x00, 0xFF, 0x00, 0x1F, 0xC0, 0x03, 0xE0, 0x00, 0x30, 0x00,
  0x00, 0x60, 0x06, 0x00, 0x70, 0x07, 0x00, 0x70, 0x07, 0x00, 0x70, 0x07,
  0x00, 0x70, 0x06, 0x00, 0x60, 0x0E, 0x00, 0xE0, 0x0E, 0x3E, 0xEF, 0xFF,
  0xFF, 0xFC, 0x3F, 0x83, 0xF0, 0x3F, 0x07, 0xE0, 0x7E, 0x07, 0xE0, 0x6E,
  0x06, 0xE0, 0x64, 0x06, 0x6D, 0xB6, 0xDB, 0xFF, 0xFF, 0xDA, 0x00, 0xC0,
  0x30, 0x0C, 0x03, 0x01, 0xC0, 0x70, 0x1C, 0x07, 0x01, 0xC0, 0x70, 0x18,
  0x0E, 0x03, 0x80, 0xE0, 0x38, 0x0C, 0x07, 0x01, 0xC0, 0x72, 0x18, 0xCE,
  0x33, 0x8C, 0xC1, 0xF0, 0x78, 0x0E, 0x00, 0x10, 0x06, 0x00, 0xE0, 0x1C,
  0x03, 0x80, 0x70, 0x0C, 0x01, 0x81, 0x70, 0x6E, 0x1D, 0xC7, 0x39, 0xC7,
  0x78, 0xEE, 0x1B, 0x83, 0xE0, 0x78, 0x0F, 0x03, 0xC0, 0x7C, 0x0F, 0xC1,
  0xDE, 0x39, 0xE6, 0x1E, 0xC0, 0xE0, 0x33, 0x33, 0x77, 0x77, 0x77, 0x77,
  0x6E, 0xEE, 0xEE, 0xEE, 0xEE, 0xE6, 0x40, 0x01, 0xE0, 0x06, 0x7E, 0x38,
  0xDF, 0xCF, 0x9F, 0xBB, 0xF7, 0xE7, 0xFE, 0xF8, 0xFD, 0x9F, 0x1F, 0x33,
  0xC3, 0xC6, 0xF8, 0x71, 0xDE, 0x1E, 0x3B, 0xC3, 0x86, 0x70, 0x00, 0xCE,
  0x00, 0x19, 0xC0, 0x02, 0x10, 0x00, 0x00, 0x38, 0x61, 0xCF, 0x8E, 0xFE,
  0x6E, 0x33, 0xE1, 0x9E, 0x0D, 0xE0, 0xEF, 0x06, 0x70, 0x33, 0x83, 0xB8,
  0x19, 0xC0, 0xC4, 0x06, 0x00, 0x07, 0x0F, 0xCE, 0x66, 0x37, 0x1B, 0x0D,
  0x87, 0x83, 0xC1, 0xE0, 0xF8, 0xFC, 0xE7, 0xE1, 0xE0, 0x00, 0xC1, 0x1F,
  0x9F, 0xFE, 0xF8, 0x77, 0x83, 0xB8, 0x1D, 0xC0, 0xEE, 0x07, 0x70, 0x3B,
  0x81, 0x9C, 0x1C, 0xE0, 0xE7, 0x0E, 0x38, 0xF1, 0xFF, 0x0F, 0xF0, 0x77,
  0x03, 0x80, 0x18, 0x01, 0xC0, 0x0E, 0x00, 0x70, 0x03, 0x80, 0x1C, 0x00,
  0xE0, 0x07, 0x00, 0x10, 0x00, 0x00, 0xF0, 0x1F, 0xC3, 0xFE, 0x3E, 0xF3,
  0xC3, 0x9C, 0x1D, 0xC0, 0xEC, 0x0E, 0xE0, 0x77, 0x07, 0xB8, 0x39, 0xC3,
  0xCF, 0xFE, 0x7F, 0xE1, 0xF7, 0x00, 0x78, 0x03, 0x80, 0x3C, 0x01, 0xC0,
  0x1E, 0x00, 0xF0, 0x0F, 0x00, 0x78, 0x03, 0x80, 0x3C, 0x01, 0xE0, 0x0E,
  0x00, 0x70, 0x00, 0x00, 0x00, 0x19, 0x9F, 0xCF, 0xC7, 0x03, 0x81, 0x81,
  0xC0, 0xE0, 0x70, 0x30, 0x18, 0x1C, 0x06, 0x02, 0x00, 0x03, 0x81, 0xFC,
  0x70, 0x8C, 0x01, 0x80, 0x30, 0x07, 0x00, 0x60, 0x06, 0x00, 0xE0, 0x0E,
  0x00, 0xE0, 0x1D, 0xFF, 0xBF, 0xF0, 0xE0, 0x00, 0x60, 0x00, 0xE0, 0x00,
  0xE0, 0x01, 0xE0, 0x01, 0xC0, 0x01, 0xC0, 0xFF, 0xCE, 0x7F, 0xFF, 0x1F,
  0xFC, 0x03, 0x80, 0x03, 0x80, 0x03, 0x80, 0x03, 0x80, 0x07, 0x00, 0x07,
  0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x07, 0x00, 0x0E, 0x00, 0x0E,
  0x00, 0x0E, 0x00, 0x0E, 0x00, 0x0C, 0x00, 0x1C, 0x00, 0x1C, 0x00, 0x08,
  0x00, 0x00, 0xD8, 0x36, 0x0F, 0x87, 0xE1, 0xF8, 0x7C, 0x1F, 0x0E, 0xC3,
  0xB0, 0xEC, 0x73, 0x3C, 0xFE, 0x3F, 0x87, 0xC0, 0x80, 0x00, 0x60, 0x0F,
  0x03, 0xE0, 0x6C, 0x0D, 0x83, 0xB0, 0x76, 0x0C, 0xE3, 0x9C, 0x61, 0x8C,
  0x33, 0x07, 0xE0, 0x78, 0x06, 0x00, 0x00, 0x20, 0x01, 0x80, 0x0C, 0x00,
  0x60, 0x03, 0x00, 0x18, 0x00, 0xF8, 0x07, 0xC0, 0x3E, 0x01, 0xF0, 0x0D,
  0x80, 0x6C, 0x03, 0x60, 0x1B, 0x00, 0xD8, 0xE7, 0xEF, 0xBF, 0xFD, 0xDE,
  0x7C, 0x61, 0xE0, 0x06, 0x00, 0xC0, 0x7C, 0x1F, 0x87, 0xF1, 0xE7, 0x78,
  0xFE, 0x0F, 0x80, 0xF0, 0x3C, 0x0F, 0xC1, 0xFC, 0x7B, 0x8E, 0x79, 0xC7,
  0xB8, 0xF0, 0x06, 0x00, 0x6C, 0x0F, 0xE0, 0xFE, 0x0E, 0xE1, 0xEF, 0x1C,
  0xF1, 0xCF, 0x1C, 0x73, 0x87, 0x38, 0x73, 0x87, 0x70, 0x7F, 0x03, 0xF0,
  0x3E, 0x03, 0xE0, 0x3C, 0x03, 0xC0, 0x3C, 0x03, 0x80, 0x38, 0x07, 0x80,
  0x70, 0x07, 0x00, 0xF0, 0x0F, 0x00, 0xF0, 0x0E, 0x00, 0xE0, 0x0E, 0x00,
  0xC0, 0x00, 0x03, 0xE0, 0x0F, 0xF8, 0x00, 0xFC, 0x00, 0x1C, 0x00, 0x78,
  0x00, 0xF0, 0x01, 0xE0, 0x07, 0xC0, 0x0F, 0x00, 0x1E, 0x00, 0x3C, 0x00,
  0x70, 0x00, 0xEF, 0xFE, 0xFF, 0xFF, 0xFE, 0x70, 0x00, 0x00, 0x00, 0x00 };



// Approx. 3660 bytes

#elif defined(SOKOL_DUMMY_BACKEND)
static const char* _sdtx_vs_src_dummy = "";
static const char* _sdtx_fs_src_dummy = "";
#else
#error "Please define one of SOKOL_GLCORE33, SOKOL_GLES2, SOKOL_GLES3, SOKOL_D3D11, SOKOL_METAL, SOKOL_WGPU or SOKOL_DUMMY_BACKEND!"
#endif

typedef struct {
    uint32_t id;
    sg_resource_state state;
} _sdtx_slot_t;

typedef struct {
    int size;
    int queue_top;
    uint32_t* gen_ctrs;
    int* free_queue;
} _sdtx_pool_t;

typedef struct {
    float x, y;
} _sdtx_float2_t;

typedef struct {
    float x, y;
    uint16_t u, v;
    uint32_t color;
} _sdtx_vertex_t;

typedef struct {
    _sdtx_slot_t slot;
    sdtx_context_desc_t desc;
    _sdtx_vertex_t* cur_vertex_ptr;
    const _sdtx_vertex_t* max_vertex_ptr;
    _sdtx_vertex_t* vertices;
    sg_buffer vbuf;
    sg_pipeline pip;
    int cur_font;
    _sdtx_float2_t canvas_size;
    _sdtx_float2_t glyph_size;
    _sdtx_float2_t origin;
    _sdtx_float2_t pos;
    float tab_width;
    uint32_t color;
} _sdtx_context_t;

typedef struct {
    _sdtx_pool_t pool;
    _sdtx_context_t* contexts;
} _sdtx_context_pool_t;

typedef struct {
    uint32_t init_cookie;
    sdtx_desc_t desc;
    sg_image font_img;
    sg_shader shader;
    uint32_t fmt_buf_size;
    char* fmt_buf;
    sdtx_context def_ctx_id;
    sdtx_context cur_ctx_id;
    _sdtx_context_t* cur_ctx;   // may be 0!
    _sdtx_context_pool_t context_pool;
    uint8_t font_pixels[SDTX_MAX_FONTS * 256 * 8 * 8];
} _sdtx_t;
static _sdtx_t _sdtx;

/*=== CONTEXT POOL ===========================================================*/
static void _sdtx_init_pool(_sdtx_pool_t* pool, int num) {
    SOKOL_ASSERT(pool && (num >= 1));
    /* slot 0 is reserved for the 'invalid id', so bump the pool size by 1 */
    pool->size = num + 1;
    pool->queue_top = 0;
    /* generation counters indexable by pool slot index, slot 0 is reserved */
    size_t gen_ctrs_size = sizeof(uint32_t) * pool->size;
    pool->gen_ctrs = (uint32_t*) SOKOL_MALLOC(gen_ctrs_size);
    SOKOL_ASSERT(pool->gen_ctrs);
    memset(pool->gen_ctrs, 0, gen_ctrs_size);
    /* it's not a bug to only reserve 'num' here */
    pool->free_queue = (int*) SOKOL_MALLOC(sizeof(int)*num);
    SOKOL_ASSERT(pool->free_queue);
    /* never allocate the zero-th pool item since the invalid id is 0 */
    for (int i = pool->size-1; i >= 1; i--) {
        pool->free_queue[pool->queue_top++] = i;
    }
}

static void _sdtx_discard_pool(_sdtx_pool_t* pool) {
    SOKOL_ASSERT(pool);
    SOKOL_ASSERT(pool->free_queue);
    SOKOL_FREE(pool->free_queue);
    pool->free_queue = 0;
    SOKOL_ASSERT(pool->gen_ctrs);
    SOKOL_FREE(pool->gen_ctrs);
    pool->gen_ctrs = 0;
    pool->size = 0;
    pool->queue_top = 0;
}

static int _sdtx_pool_alloc_index(_sdtx_pool_t* pool) {
    SOKOL_ASSERT(pool);
    SOKOL_ASSERT(pool->free_queue);
    if (pool->queue_top > 0) {
        int slot_index = pool->free_queue[--pool->queue_top];
        SOKOL_ASSERT((slot_index > 0) && (slot_index < pool->size));
        return slot_index;
    }
    else {
        /* pool exhausted */
        return _SDTX_INVALID_SLOT_INDEX;
    }
}

static void _sdtx_pool_free_index(_sdtx_pool_t* pool, int slot_index) {
    SOKOL_ASSERT((slot_index > _SDTX_INVALID_SLOT_INDEX) && (slot_index < pool->size));
    SOKOL_ASSERT(pool);
    SOKOL_ASSERT(pool->free_queue);
    SOKOL_ASSERT(pool->queue_top < pool->size);
    #ifdef SOKOL_DEBUG
    /* debug check against double-free */
    for (int i = 0; i < pool->queue_top; i++) {
        SOKOL_ASSERT(pool->free_queue[i] != slot_index);
    }
    #endif
    pool->free_queue[pool->queue_top++] = slot_index;
    SOKOL_ASSERT(pool->queue_top <= (pool->size-1));
}

static void _sdtx_setup_context_pool(const sdtx_desc_t* desc) {
    SOKOL_ASSERT(desc);
    /* note: the pool will have an additional item, since slot 0 is reserved */
    SOKOL_ASSERT((desc->context_pool_size > 0) && (desc->context_pool_size < _SDTX_MAX_POOL_SIZE));
    _sdtx_init_pool(&_sdtx.context_pool.pool, desc->context_pool_size);
    size_t pool_byte_size = sizeof(_sdtx_context_t) * _sdtx.context_pool.pool.size;
    _sdtx.context_pool.contexts = (_sdtx_context_t*) SOKOL_MALLOC(pool_byte_size);
    SOKOL_ASSERT(_sdtx.context_pool.contexts);
    memset(_sdtx.context_pool.contexts, 0, pool_byte_size);
}

static void _sdtx_discard_context_pool(void) {
    SOKOL_ASSERT(_sdtx.context_pool.contexts);
    SOKOL_FREE(_sdtx.context_pool.contexts);
    _sdtx.context_pool.contexts = 0;
    _sdtx_discard_pool(&_sdtx.context_pool.pool);
}

/* allocate the slot at slot_index:
    - bump the slot's generation counter
    - create a resource id from the generation counter and slot index
    - set the slot's id to this id
    - set the slot's state to ALLOC
    - return the resource id
*/
static uint32_t _sdtx_slot_alloc(_sdtx_pool_t* pool, _sdtx_slot_t* slot, int slot_index) {
    /* FIXME: add handling for an overflowing generation counter,
       for now, just overflow (another option is to disable
       the slot)
    */
    SOKOL_ASSERT(pool && pool->gen_ctrs);
    SOKOL_ASSERT((slot_index > _SDTX_INVALID_SLOT_INDEX) && (slot_index < pool->size));
    SOKOL_ASSERT((slot->state == SG_RESOURCESTATE_INITIAL) && (slot->id == SG_INVALID_ID));
    uint32_t ctr = ++pool->gen_ctrs[slot_index];
    slot->id = (ctr<<_SDTX_SLOT_SHIFT)|(slot_index & _SDTX_SLOT_MASK);
    slot->state = SG_RESOURCESTATE_ALLOC;
    return slot->id;
}

/* extract slot index from id */
static int _sdtx_slot_index(uint32_t id) {
    int slot_index = (int) (id & _SDTX_SLOT_MASK);
    SOKOL_ASSERT(_SDTX_INVALID_SLOT_INDEX != slot_index);
    return slot_index;
}

/* get context pointer without id-check */
static _sdtx_context_t* _sdtx_context_at(uint32_t ctx_id) {
    SOKOL_ASSERT(SG_INVALID_ID != ctx_id);
    int slot_index = _sdtx_slot_index(ctx_id);
    SOKOL_ASSERT((slot_index > _SDTX_INVALID_SLOT_INDEX) && (slot_index < _sdtx.context_pool.pool.size));
    return &_sdtx.context_pool.contexts[slot_index];
}

/* get context pointer with id-check, returns 0 if no match */
static _sdtx_context_t* _sdtx_lookup_context(uint32_t ctx_id) {
    if (SG_INVALID_ID != ctx_id) {
        _sdtx_context_t* ctx = _sdtx_context_at(ctx_id);
        if (ctx->slot.id == ctx_id) {
            return ctx;
        }
    }
    return 0;
}

/* make context handle from raw uint32_t id */
static sdtx_context _sdtx_make_ctx_id(uint32_t ctx_id) {
    sdtx_context ctx;
    ctx.id = ctx_id;
    return ctx;
}

static sdtx_context _sdtx_alloc_context(void) {
    sdtx_context ctx_id;
    int slot_index = _sdtx_pool_alloc_index(&_sdtx.context_pool.pool);
    if (_SDTX_INVALID_SLOT_INDEX != slot_index) {
        ctx_id = _sdtx_make_ctx_id(_sdtx_slot_alloc(&_sdtx.context_pool.pool, &_sdtx.context_pool.contexts[slot_index].slot, slot_index));
    }
    else {
        /* pool is exhausted */
        ctx_id = _sdtx_make_ctx_id(SG_INVALID_ID);
    }
    return ctx_id;
}

static sdtx_context_desc_t _sdtx_context_desc_defaults(const sdtx_context_desc_t* desc) {
    sdtx_context_desc_t res = *desc;
    res.char_buf_size = _sdtx_def(res.char_buf_size, _SDTX_DEFAULT_CHAR_BUF_SIZE);
    res.canvas_width = _sdtx_def(res.canvas_width, _SDTX_DEFAULT_CANVAS_WIDTH);
    res.canvas_height = _sdtx_def(res.canvas_height, _SDTX_DEFAULT_CANVAS_HEIGHT);
    res.tab_width = _sdtx_def(res.tab_width, _SDTX_DEFAULT_TAB_WIDTH);
    /* keep pixel format attrs are passed as is into pipeline creation */
    return res;
}

static void _sdtx_init_context(sdtx_context ctx_id, const sdtx_context_desc_t* in_desc) {
    sg_push_debug_group("sokol-debugtext");

    SOKOL_ASSERT((ctx_id.id != SG_INVALID_ID) && in_desc);
    _sdtx_context_t* ctx = _sdtx_lookup_context(ctx_id.id);
    SOKOL_ASSERT(ctx);
    ctx->desc = _sdtx_context_desc_defaults(in_desc);
    SOKOL_ASSERT(ctx->desc.canvas_width > 0.0f);
    SOKOL_ASSERT(ctx->desc.canvas_height > 0.0f);

    const uint32_t max_vertices = 6 * ctx->desc.char_buf_size;
    const int vbuf_size = max_vertices * sizeof(_sdtx_vertex_t);
    ctx->vertices = (_sdtx_vertex_t*) SOKOL_MALLOC(vbuf_size);
    SOKOL_ASSERT(ctx->vertices);
    ctx->cur_vertex_ptr = ctx->vertices;
    ctx->max_vertex_ptr = ctx->vertices + max_vertices;

    sg_buffer_desc vbuf_desc;
    memset(&vbuf_desc, 0, sizeof(vbuf_desc));
    vbuf_desc.size = vbuf_size;
    vbuf_desc.type = SG_BUFFERTYPE_VERTEXBUFFER;
    vbuf_desc.usage = SG_USAGE_STREAM;
    vbuf_desc.label = "sdtx-vbuf";
    ctx->vbuf = sg_make_buffer(&vbuf_desc);
    SOKOL_ASSERT(SG_INVALID_ID != ctx->vbuf.id);

    sg_pipeline_desc pip_desc;
    memset(&pip_desc, 0, sizeof(pip_desc));
    pip_desc.layout.buffers[0].stride = sizeof(_sdtx_vertex_t);
    pip_desc.layout.attrs[0].format = SG_VERTEXFORMAT_FLOAT2;
    pip_desc.layout.attrs[1].format = SG_VERTEXFORMAT_USHORT2N;
    pip_desc.layout.attrs[2].format = SG_VERTEXFORMAT_UBYTE4N;
    pip_desc.shader = _sdtx.shader;
    pip_desc.index_type = SG_INDEXTYPE_NONE;
    pip_desc.blend.enabled = true;
    pip_desc.blend.src_factor_rgb = SG_BLENDFACTOR_SRC_ALPHA;
    pip_desc.blend.dst_factor_rgb = SG_BLENDFACTOR_ONE_MINUS_SRC_ALPHA;
    pip_desc.blend.src_factor_alpha = SG_BLENDFACTOR_ZERO;
    pip_desc.blend.dst_factor_alpha = SG_BLENDFACTOR_ONE;
    pip_desc.blend.color_format = ctx->desc.color_format;
    pip_desc.blend.depth_format = ctx->desc.depth_format;
    pip_desc.rasterizer.sample_count = ctx->desc.sample_count;
    pip_desc.label = "sdtx-pipeline";
    ctx->pip = sg_make_pipeline(&pip_desc);
    SOKOL_ASSERT(SG_INVALID_ID != ctx->pip.id);

    ctx->canvas_size.x = ctx->desc.canvas_width;
    ctx->canvas_size.y = ctx->desc.canvas_height;
    ctx->glyph_size.x = 8.0f / ctx->canvas_size.x;
    ctx->glyph_size.y = 8.0f / ctx->canvas_size.y;
    ctx->tab_width = (float) ctx->desc.tab_width;
    ctx->color = _SDTX_DEFAULT_COLOR;

    sg_pop_debug_group();
}

static void _sdtx_destroy_context(sdtx_context ctx_id) {
    _sdtx_context_t* ctx = _sdtx_lookup_context(ctx_id.id);
    if (ctx) {
        if (ctx->vertices) {
            SOKOL_FREE(ctx->vertices);
            ctx->vertices = 0;
            ctx->cur_vertex_ptr = 0;
            ctx->max_vertex_ptr = 0;
        }
        sg_push_debug_group("sokol_debugtext");
        sg_destroy_buffer(ctx->vbuf);
        sg_destroy_pipeline(ctx->pip);
        sg_pop_debug_group();
        memset(ctx, 0, sizeof(*ctx));
        _sdtx_pool_free_index(&_sdtx.context_pool.pool, _sdtx_slot_index(ctx_id.id));
    }
}

static bool _sdtx_is_default_context(sdtx_context ctx_id) {
    return ctx_id.id == SDTX_DEFAULT_CONTEXT.id;
}

/* unpack linear 8x8 bits-per-pixel font data into 2D byte-per-pixel texture data */
static void _sdtx_unpack_font(const sdtx_font_desc_t* font_desc, uint8_t* out_pixels) {
    SOKOL_ASSERT(font_desc->ptr);
    SOKOL_ASSERT((font_desc->size > 0) && ((font_desc->size % 8) == 0));
    SOKOL_ASSERT(font_desc->first_char <= font_desc->last_char);
    SOKOL_ASSERT((((font_desc->last_char - font_desc->first_char) + 1) * 8) == font_desc->size);
    const uint8_t* ptr = font_desc->ptr;
    for (int chr = font_desc->first_char; chr <= font_desc->last_char; chr++) {
        for (int line = 0; line < 8; line++) {
            uint8_t bits = *ptr++;
            for (int x = 0; x < 8; x++) {
                out_pixels[line*256*8 + chr*8 + x] = ((bits>>(7-x)) & 1) ? 0xFF : 0x00;
            }
        }
    }
}

static void _sdtx_setup_common(void) {

    /* common printf formatting buffer */
    _sdtx.fmt_buf_size = _sdtx.desc.printf_buf_size + 1;
    _sdtx.fmt_buf = (char*) SOKOL_MALLOC(_sdtx.fmt_buf_size);
    SOKOL_ASSERT(_sdtx.fmt_buf);

    sg_push_debug_group("sokol-debugtext");

    /* common shader for all contexts */
    sg_shader_desc shd_desc;
    memset(&shd_desc, 0, sizeof(shd_desc));
    shd_desc.label = "sokol-debugtext-shader";
    shd_desc.attrs[0].name = "position";
    shd_desc.attrs[1].name = "texcoord0";
    shd_desc.attrs[2].name = "color0";
    shd_desc.attrs[0].sem_name = "TEXCOORD";
    shd_desc.attrs[0].sem_index = 0;
    shd_desc.attrs[1].sem_name = "TEXCOORD";
    shd_desc.attrs[1].sem_index = 1;
    shd_desc.attrs[2].sem_name = "TEXCOORD";
    shd_desc.attrs[2].sem_index = 2;
    shd_desc.fs.images[0].name = "tex";
    shd_desc.fs.images[0].type = SG_IMAGETYPE_2D;
    shd_desc.fs.images[0].sampler_type = SG_SAMPLERTYPE_FLOAT;
    _sdtx.shader = sg_make_shader(&shd_desc);
    SOKOL_ASSERT(SG_INVALID_ID != _sdtx.shader.id);

    /* unpack font data */
    memset(_sdtx.font_pixels, 0xFF, sizeof(_sdtx.font_pixels));
    const int unpacked_font_size = 256 * 8 * 8;
    for (int i = 0; i < SDTX_MAX_FONTS; i++) {
        if (_sdtx.desc.fonts[i].ptr) {
            _sdtx_unpack_font(&_sdtx.desc.fonts[i], &_sdtx.font_pixels[i * unpacked_font_size]);
        }
    }

    /* create font texture */
    sg_image_desc img_desc;
    memset(&img_desc, 0, sizeof(img_desc));
    img_desc.width = 256 * 8;
    img_desc.height = SDTX_MAX_FONTS * 8;
    img_desc.pixel_format = SG_PIXELFORMAT_R8;
    img_desc.min_filter = SG_FILTER_NEAREST;
    img_desc.mag_filter = SG_FILTER_NEAREST;
    img_desc.wrap_u = SG_WRAP_CLAMP_TO_EDGE;
    img_desc.wrap_v = SG_WRAP_CLAMP_TO_EDGE;
    img_desc.content.subimage[0][0].ptr = _sdtx.font_pixels;
    img_desc.content.subimage[0][0].size = sizeof(_sdtx.font_pixels);
    _sdtx.font_img = sg_make_image(&img_desc);
    SOKOL_ASSERT(SG_INVALID_ID != _sdtx.font_img.id);

    sg_pop_debug_group();
}

static void _sdtx_discard_common(void) {
    sg_push_debug_group("sokol-debugtext");
    sg_destroy_image(_sdtx.font_img);
    sg_destroy_shader(_sdtx.shader);
    if (_sdtx.fmt_buf) {
        SOKOL_FREE(_sdtx.fmt_buf);
        _sdtx.fmt_buf = 0;
    }
    sg_pop_debug_group();
}

static inline uint32_t _sdtx_pack_rgbab(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
    return (uint32_t)(((uint32_t)a<<24)|((uint32_t)b<<16)|((uint32_t)g<<8)|r);
}

static inline float _sdtx_clamp(float v, float lo, float hi) {
    if (v < lo) return lo;
    else if (v > hi) return hi;
    else return v;
}

static inline uint32_t _sdtx_pack_rgbaf(float r, float g, float b, float a) {
    uint8_t r_u8 = (uint8_t) (_sdtx_clamp(r, 0.0f, 1.0f) * 255.0f);
    uint8_t g_u8 = (uint8_t) (_sdtx_clamp(g, 0.0f, 1.0f) * 255.0f);
    uint8_t b_u8 = (uint8_t) (_sdtx_clamp(b, 0.0f, 1.0f) * 255.0f);
    uint8_t a_u8 = (uint8_t) (_sdtx_clamp(a, 0.0f, 1.0f) * 255.0f);
    return _sdtx_pack_rgbab(r_u8, g_u8, b_u8, a_u8);
}

static inline void _sdtx_ctrl_char(_sdtx_context_t* ctx, uint8_t c) {
    switch (c) {
        case '\r':
            ctx->pos.x = 0.0f;
            break;
        case '\n':
            ctx->pos.x = 0.0f;
            ctx->pos.y += 1.0f;
            break;
        case '\t':
            ctx->pos.x = (ctx->pos.x - fmodf(ctx->pos.x, ctx->tab_width)) + ctx->tab_width;
            break;
        case ' ':
            ctx->pos.x += 1.0f;
            break;
    }
}

static inline void _sdtx_draw_char(_sdtx_context_t* ctx, uint8_t c) {
    if ((ctx->cur_vertex_ptr + 6) <= ctx->max_vertex_ptr) {
        const float x0 = (ctx->origin.x + ctx->pos.x) * ctx->glyph_size.x;
        const float y0 = (ctx->origin.y + ctx->pos.y) * ctx->glyph_size.y;
        const float x1 = x0 + ctx->glyph_size.x;
        const float y1 = y0 + ctx->glyph_size.y;

        // glyph width and heigth in font texture space
        const uint16_t uvw = 0x10000 / 0x100;
        const uint16_t uvh = 0x10000 / SDTX_MAX_FONTS;
        const uint16_t u0 = ((uint16_t)c) * uvw;
        const uint16_t v0 = ((uint16_t)ctx->cur_font) * uvh;
        uint16_t u1 = u0 + uvw;
        uint16_t v1 = v0 + uvh;
        if (u1 == 0x0000) {
            u1 = 0xFFFF;
        }
        if (v1 == 0x0000) {
            v1 = 0xFFFF;
        }
        const uint32_t color = ctx->color;

        // write 6 vertices
        _sdtx_vertex_t* vx = ctx->cur_vertex_ptr;

        vx->x=x0; vx->y=y0; vx->u = u0; vx->v = v0; vx->color = color; vx++;
        vx->x=x1; vx->y=y0; vx->u = u1; vx->v = v0; vx->color = color; vx++;
        vx->x=x1; vx->y=y1; vx->u = u1; vx->v = v1; vx->color = color; vx++;

        vx->x=x0; vx->y=y0; vx->u = u0; vx->v = v0; vx->color = color; vx++;
        vx->x=x1; vx->y=y1; vx->u = u1; vx->v = v1; vx->color = color; vx++;
        vx->x=x0; vx->y=y1; vx->u = u0; vx->v = v1; vx->color = color; vx++;

        ctx->cur_vertex_ptr = vx;
    }
    ctx->pos.x += 1.0f;
}

static inline void _sdtx_put_char(_sdtx_context_t* ctx, char c) {
    uint8_t c_u8 = c;
    if (c_u8 <= 32) {
        _sdtx_ctrl_char(ctx, c_u8);
    }
    else {
        _sdtx_draw_char(ctx, c_u8);
    }
}

static sdtx_desc_t _sdtx_desc_defaults(const sdtx_desc_t* in_desc) {
    sdtx_desc_t desc = *in_desc;
    desc.context_pool_size = _sdtx_def(desc.context_pool_size, _SDTX_DEFAULT_CONTEXT_POOL_SIZE);
    desc.printf_buf_size = _sdtx_def(desc.printf_buf_size, _SDTX_DEFAULT_PRINTF_BUF_SIZE);
    for (int i = 0; i < SDTX_MAX_FONTS; i++) {
        if (desc.fonts[i].ptr) {
            desc.fonts[i].last_char = _sdtx_def(desc.fonts[i].last_char, 255);
        }
    }
    desc.context = _sdtx_context_desc_defaults(&desc.context);
    return desc;
}

/*=== PUBLIC API FUNCTIONS ===================================================*/
SOKOL_API_IMPL void sdtx_setup(const sdtx_desc_t* desc) {
    SOKOL_ASSERT(desc);
    memset(&_sdtx, 0, sizeof(_sdtx));
    _sdtx.init_cookie = _SDTX_INIT_COOKIE;
    _sdtx.desc = _sdtx_desc_defaults(desc);
    _sdtx_setup_context_pool(&_sdtx.desc);
    _sdtx_setup_common();
    _sdtx.def_ctx_id = sdtx_make_context(&_sdtx.desc.context);
    SOKOL_ASSERT(SDTX_DEFAULT_CONTEXT.id == _sdtx.def_ctx_id.id);
    sdtx_set_context(_sdtx.def_ctx_id);
}

SOKOL_API_IMPL void sdtx_shutdown(void) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    for (int i = 0; i < _sdtx.context_pool.pool.size; i++) {
        _sdtx_context_t* ctx = &_sdtx.context_pool.contexts[i];
        _sdtx_destroy_context(_sdtx_make_ctx_id(ctx->slot.id));
    }
    _sdtx_discard_common();
    _sdtx_discard_context_pool();
    _sdtx.init_cookie = 0;
}

SOKOL_API_IMPL sdtx_font_desc_t _elie_font_Weigl(void) {
    sdtx_font_desc_t desc = { _elie_font_Weigl, sizeof(_elie_font_Weigl), 0, 255 };
    return desc;
}


SOKOL_API_IMPL sdtx_context sdtx_make_context(const sdtx_context_desc_t* desc) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    SOKOL_ASSERT(desc);
    sdtx_context ctx_id = _sdtx_alloc_context();
    if (ctx_id.id != SG_INVALID_ID) {
        _sdtx_init_context(ctx_id, desc);
    }
    else {
        SOKOL_LOG("sokol_debugtext.h: context pool exhausted!");
    }
    return ctx_id;
}

SOKOL_API_IMPL void sdtx_destroy_context(sdtx_context ctx_id) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    if (_sdtx_is_default_context(ctx_id)) {
        SOKOL_LOG("sokol_debugtext.h: cannot destroy default context");
        return;
    }
    _sdtx_destroy_context(ctx_id);
    // re-validate the current context pointer (this will return a nullptr
    // if we just destroyed the current context)
    _sdtx.cur_ctx = _sdtx_lookup_context(_sdtx.cur_ctx_id.id);
}

SOKOL_API_IMPL void sdtx_set_context(sdtx_context ctx_id) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    if (_sdtx_is_default_context(ctx_id)) {
        _sdtx.cur_ctx_id = _sdtx.def_ctx_id;
    }
    else {
        _sdtx.cur_ctx_id = ctx_id;
    }
    // this may return a nullptr if the ctx_id handle is invalid
    _sdtx.cur_ctx = _sdtx_lookup_context(_sdtx.cur_ctx_id.id);
}

SOKOL_API_IMPL sdtx_context sdtx_get_context(void) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    return _sdtx.cur_ctx_id;
}

SOKOL_API_IMPL void sdtx_font(int font_index) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    SOKOL_ASSERT((font_index >= 0) && (font_index < SDTX_MAX_FONTS));
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->cur_font = font_index;
    }
}

SOKOL_API_IMPL void sdtx_canvas(float w, float h) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    SOKOL_ASSERT((w > 0.0f) && (h > 0.0f));
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->canvas_size.x = w;
        ctx->canvas_size.y = h;
        ctx->glyph_size.x = (8.0f / ctx->canvas_size.x);
        ctx->glyph_size.y = (8.0f / ctx->canvas_size.y);
        ctx->origin.x = 0.0f;
        ctx->origin.y = 0.0f;
        ctx->pos.x = 0.0f;
        ctx->pos.y = 0.0f;
    }
}

SOKOL_API_IMPL void sdtx_origin(float x, float y) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->origin.x = x;
        ctx->origin.y = y;
    }
}

SOKOL_API_IMPL void sdtx_home(void) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->pos.x = 0.0f;
        ctx->pos.y = 0.0f;
    }
}

SOKOL_API_IMPL void sdtx_pos(float x, float y) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->pos.x = x;
        ctx->pos.y = y;
    }
}

SOKOL_API_IMPL void sdtx_pos_x(float x) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->pos.x = x;
    }
}

SOKOL_API_IMPL void sdtx_pos_y(float y) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->pos.y = y;
    }
}

SOKOL_API_IMPL void sdtx_move(float dx, float dy) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->pos.x += dx;
        ctx->pos.y += dy;
    }
}

SOKOL_API_IMPL void sdtx_move_x(float dx) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->pos.x += dx;
    }
}

SOKOL_API_IMPL void sdtx_move_y(float dy) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->pos.y += dy;
    }
}

SOKOL_API_IMPL void sdtx_crlf(void) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->pos.x = 0.0f;
        ctx->pos.y += 1.0f;
    }
}

SOKOL_API_IMPL void sdtx_color3b(uint8_t r, uint8_t g, uint8_t b) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->color = _sdtx_pack_rgbab(r, g, b, 255);
    }
}

SOKOL_API_IMPL void sdtx_color3f(float r, float g, float b) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->color = _sdtx_pack_rgbaf(r, g, b, 1.0f);
    }
}

SOKOL_API_IMPL void sdtx_color4b(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->color = _sdtx_pack_rgbab(r, g, b, a);
    }
}

SOKOL_API_IMPL void sdtx_color4f(float r, float g, float b, float a) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->color = _sdtx_pack_rgbaf(r, g, b, a);
    }
}

SOKOL_API_IMPL void sdtx_color1i(uint32_t rgba) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        ctx->color = rgba;
    }
}

SOKOL_API_DECL void sdtx_putc(char chr) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        _sdtx_put_char(ctx, chr);
    }
}

SOKOL_API_DECL void sdtx_puts(const char* str) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        char chr;
        while (0 != (chr = *str++)) {
            _sdtx_put_char(ctx, chr);
        }
    }
}

SOKOL_API_DECL void sdtx_putr(const char* str, int len) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        for (int i = 0; i < len; i++) {
            char chr = str[i];
            if (0 == chr) {
                break;
            }
            _sdtx_put_char(ctx, chr);
        }
    }
}

SOKOL_API_DECL int sdtx_vprintf(const char* fmt, va_list args) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    SOKOL_ASSERT(_sdtx.fmt_buf && (_sdtx.fmt_buf_size >= 2));
    int res = SOKOL_VSNPRINTF(_sdtx.fmt_buf, _sdtx.fmt_buf_size, fmt, args);
    // make sure we're 0-terminated in case we're on an old MSVC
    _sdtx.fmt_buf[_sdtx.fmt_buf_size-1] = 0;
    sdtx_puts(_sdtx.fmt_buf);
    return res;
}

SOKOL_API_DECL int sdtx_printf(const char* fmt, ...) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    SOKOL_ASSERT(_sdtx.fmt_buf && (_sdtx.fmt_buf_size >= 2));
    va_list args;
    va_start(args, fmt);
    int res = SOKOL_VSNPRINTF(_sdtx.fmt_buf, _sdtx.fmt_buf_size, fmt, args);
    va_end(args);
    // make sure we're 0-terminated in case we're on an old MSVC
    _sdtx.fmt_buf[_sdtx.fmt_buf_size-1] = 0;
    sdtx_puts(_sdtx.fmt_buf);
    return res;
}

SOKOL_API_IMPL void sdtx_draw(void) {
    SOKOL_ASSERT(_SDTX_INIT_COOKIE == _sdtx.init_cookie);
    _sdtx_context_t* ctx = _sdtx.cur_ctx;
    if (ctx) {
        const int num_verts = (int) (ctx->cur_vertex_ptr - ctx->vertices);
        if (num_verts > 0) {
            SOKOL_ASSERT((num_verts % 6) == 0);
            sg_push_debug_group("sokol-debugtext");
            int vbuf_offset = sg_append_buffer(ctx->vbuf, ctx->vertices, num_verts * sizeof(_sdtx_vertex_t));
            sg_apply_pipeline(ctx->pip);
            sg_bindings bindings;
            memset(&bindings, 0, sizeof(bindings));
            bindings.vertex_buffers[0] = ctx->vbuf;
            bindings.vertex_buffer_offsets[0] = vbuf_offset;
            bindings.fs_images[0] = _sdtx.font_img;
            sg_apply_bindings(&bindings);
            sg_draw(0, num_verts, 1);
            sg_pop_debug_group();
        }
        ctx->cur_vertex_ptr = ctx->vertices;
        ctx->cur_font = 0;
        ctx->pos.x = 0.0f;
        ctx->pos.y = 0.0f;
    }
}


